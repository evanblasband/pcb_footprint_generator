{..............................................................................}
{ Export Footprint Data Script                                                  }
{ Exports all pads, vias, tracks, and arcs from the current footprint to a     }
{ text file for ground truth comparison.                                        }
{                                                                               }
{ Usage:                                                                        }
{ 1. Open a PCB Library (.PcbLib) in Altium Designer                           }
{ 2. Select the footprint component you want to export                          }
{ 3. Run this script                                                            }
{ 4. Data will be saved to the same folder as the library                       }
{..............................................................................}

Function FloatToStr4(Value : Double) : String;
Begin
    Result := FormatFloat('0.0000', Value);
End;

Function FloatToStr1(Value : Double) : String;
Begin
    Result := FormatFloat('0.0', Value);
End;

Procedure ExportFootprintData;
Var
    CurrentLib     : IPCB_Library;
    Component      : IPCB_LibComponent;
    PadIterator    : IPCB_GroupIterator;
    Pad            : IPCB_Pad;
    Via            : IPCB_Via;
    Track          : IPCB_Track;
    Arc            : IPCB_Arc;
    OutputFile     : TextFile;
    OutputPath     : String;
    FootprintName  : String;
    PadCount       : Integer;
    ViaCount       : Integer;
    TrackCount     : Integer;
    ArcCount       : Integer;
    ShapeStr       : String;
    LayerStr       : String;
    Line           : String;

Begin
    // Get the current PCB Library
    CurrentLib := PCBServer.GetCurrentPCBLibrary;
    If CurrentLib = Nil Then
    Begin
        ShowMessage('Please open a PCB Library first.');
        Exit;
    End;

    // Get current footprint
    Component := CurrentLib.CurrentComponent;
    If Component = Nil Then
    Begin
        ShowMessage('Please select a footprint component.');
        Exit;
    End;

    FootprintName := Component.Name;

    // Create output file path
    OutputPath := ExtractFilePath(CurrentLib.Board.FileName) + FootprintName + '_ground_truth.txt';

    AssignFile(OutputFile, OutputPath);
    Rewrite(OutputFile);

    // Write header
    WriteLn(OutputFile, '# Ground Truth Export for: ' + FootprintName);
    WriteLn(OutputFile, '# Generated by export_footprint_data.pas');
    WriteLn(OutputFile, '# Units: millimeters (mm)');
    WriteLn(OutputFile, '# Coordinate system: Origin at center, +X right, +Y up');
    WriteLn(OutputFile, '');

    // Initialize counters
    PadCount := 0;
    ViaCount := 0;
    TrackCount := 0;
    ArcCount := 0;

    // ========== EXPORT PADS ==========
    WriteLn(OutputFile, '## PADS');
    WriteLn(OutputFile, '# Name, X(mm), Y(mm), Width(mm), Height(mm), Shape, Layer, HoleDia(mm), Rotation(deg)');
    WriteLn(OutputFile, '');

    PadIterator := Component.GroupIterator_Create;
    PadIterator.SetState_FilterAll;
    PadIterator.AddFilter_ObjectSet(MkSet(ePadObject));

    Pad := PadIterator.FirstPCBObject;
    While Pad <> Nil Do
    Begin
        // Determine shape string
        Case Pad.TopShape Of
            eRectangular: ShapeStr := 'Rectangular';
            eRounded: ShapeStr := 'Rounded';
            eOctagonal: ShapeStr := 'Octagonal';
            eRoundedRectangular: ShapeStr := 'RoundedRectangular';
            eNoShape: ShapeStr := 'NoShape';
        Else
            ShapeStr := 'Round';
        End;

        // Determine layer string
        If Pad.Layer = eMultiLayer Then
            LayerStr := 'MultiLayer'
        Else If Pad.Layer = eTopLayer Then
            LayerStr := 'TopLayer'
        Else If Pad.Layer = eBottomLayer Then
            LayerStr := 'BottomLayer'
        Else
            LayerStr := 'Layer' + IntToStr(Pad.Layer);

        // Build output line using string concatenation
        Line := 'PAD: ' + Pad.Name;
        Line := Line + ', X=' + FloatToStr4(CoordToMMs(Pad.X));
        Line := Line + ', Y=' + FloatToStr4(CoordToMMs(Pad.Y));
        Line := Line + ', W=' + FloatToStr4(CoordToMMs(Pad.TopXSize));
        Line := Line + ', H=' + FloatToStr4(CoordToMMs(Pad.TopYSize));
        Line := Line + ', Shape=' + ShapeStr;
        Line := Line + ', Layer=' + LayerStr;
        Line := Line + ', Hole=' + FloatToStr4(CoordToMMs(Pad.HoleSize));
        Line := Line + ', Rot=' + FloatToStr1(Pad.Rotation);

        WriteLn(OutputFile, Line);

        PadCount := PadCount + 1;
        Pad := PadIterator.NextPCBObject;
    End;

    Component.GroupIterator_Destroy(PadIterator);

    WriteLn(OutputFile, '');
    WriteLn(OutputFile, '# Total Pads: ' + IntToStr(PadCount));
    WriteLn(OutputFile, '');

    // ========== EXPORT VIAS ==========
    WriteLn(OutputFile, '## VIAS');
    WriteLn(OutputFile, '# X(mm), Y(mm), HoleDia(mm), OuterDia(mm)');
    WriteLn(OutputFile, '');

    PadIterator := Component.GroupIterator_Create;
    PadIterator.SetState_FilterAll;
    PadIterator.AddFilter_ObjectSet(MkSet(eViaObject));

    Via := PadIterator.FirstPCBObject;
    While Via <> Nil Do
    Begin
        Line := 'VIA: X=' + FloatToStr4(CoordToMMs(Via.X));
        Line := Line + ', Y=' + FloatToStr4(CoordToMMs(Via.Y));
        Line := Line + ', Hole=' + FloatToStr4(CoordToMMs(Via.HoleSize));
        Line := Line + ', Size=' + FloatToStr4(CoordToMMs(Via.Size));

        WriteLn(OutputFile, Line);

        ViaCount := ViaCount + 1;
        Via := PadIterator.NextPCBObject;
    End;

    Component.GroupIterator_Destroy(PadIterator);

    WriteLn(OutputFile, '');
    WriteLn(OutputFile, '# Total Vias: ' + IntToStr(ViaCount));
    WriteLn(OutputFile, '');

    // ========== EXPORT TRACKS (Silkscreen) ==========
    WriteLn(OutputFile, '## TRACKS');
    WriteLn(OutputFile, '# X1(mm), Y1(mm), X2(mm), Y2(mm), Width(mm), Layer');
    WriteLn(OutputFile, '');

    PadIterator := Component.GroupIterator_Create;
    PadIterator.SetState_FilterAll;
    PadIterator.AddFilter_ObjectSet(MkSet(eTrackObject));

    Track := PadIterator.FirstPCBObject;
    While Track <> Nil Do
    Begin
        // Determine layer string
        If Track.Layer = eTopOverlay Then
            LayerStr := 'TopOverlay'
        Else If Track.Layer = eBottomOverlay Then
            LayerStr := 'BottomOverlay'
        Else If Track.Layer = eTopLayer Then
            LayerStr := 'TopLayer'
        Else
            LayerStr := 'Layer' + IntToStr(Track.Layer);

        Line := 'TRACK: X1=' + FloatToStr4(CoordToMMs(Track.X1));
        Line := Line + ', Y1=' + FloatToStr4(CoordToMMs(Track.Y1));
        Line := Line + ', X2=' + FloatToStr4(CoordToMMs(Track.X2));
        Line := Line + ', Y2=' + FloatToStr4(CoordToMMs(Track.Y2));
        Line := Line + ', Width=' + FloatToStr4(CoordToMMs(Track.Width));
        Line := Line + ', Layer=' + LayerStr;

        WriteLn(OutputFile, Line);

        TrackCount := TrackCount + 1;
        Track := PadIterator.NextPCBObject;
    End;

    Component.GroupIterator_Destroy(PadIterator);

    WriteLn(OutputFile, '');
    WriteLn(OutputFile, '# Total Tracks: ' + IntToStr(TrackCount));
    WriteLn(OutputFile, '');

    // ========== EXPORT ARCS ==========
    WriteLn(OutputFile, '## ARCS');
    WriteLn(OutputFile, '# CenterX(mm), CenterY(mm), Radius(mm), StartAngle(deg), EndAngle(deg), Width(mm), Layer');
    WriteLn(OutputFile, '');

    PadIterator := Component.GroupIterator_Create;
    PadIterator.SetState_FilterAll;
    PadIterator.AddFilter_ObjectSet(MkSet(eArcObject));

    Arc := PadIterator.FirstPCBObject;
    While Arc <> Nil Do
    Begin
        // Determine layer string
        If Arc.Layer = eTopOverlay Then
            LayerStr := 'TopOverlay'
        Else If Arc.Layer = eBottomOverlay Then
            LayerStr := 'BottomOverlay'
        Else
            LayerStr := 'Layer' + IntToStr(Arc.Layer);

        Line := 'ARC: CX=' + FloatToStr4(CoordToMMs(Arc.XCenter));
        Line := Line + ', CY=' + FloatToStr4(CoordToMMs(Arc.YCenter));
        Line := Line + ', R=' + FloatToStr4(CoordToMMs(Arc.Radius));
        Line := Line + ', Start=' + FloatToStr1(Arc.StartAngle);
        Line := Line + ', End=' + FloatToStr1(Arc.EndAngle);
        Line := Line + ', Width=' + FloatToStr4(CoordToMMs(Arc.LineWidth));
        Line := Line + ', Layer=' + LayerStr;

        WriteLn(OutputFile, Line);

        ArcCount := ArcCount + 1;
        Arc := PadIterator.NextPCBObject;
    End;

    Component.GroupIterator_Destroy(PadIterator);

    WriteLn(OutputFile, '');
    WriteLn(OutputFile, '# Total Arcs: ' + IntToStr(ArcCount));
    WriteLn(OutputFile, '');

    // Write summary
    WriteLn(OutputFile, '## SUMMARY');
    WriteLn(OutputFile, 'Footprint: ' + FootprintName);
    WriteLn(OutputFile, 'Pads: ' + IntToStr(PadCount));
    WriteLn(OutputFile, 'Vias: ' + IntToStr(ViaCount));
    WriteLn(OutputFile, 'Tracks: ' + IntToStr(TrackCount));
    WriteLn(OutputFile, 'Arcs: ' + IntToStr(ArcCount));

    CloseFile(OutputFile);

    ShowMessage('Exported to: ' + OutputPath + Chr(13) + Chr(10) +
                'Pads: ' + IntToStr(PadCount) + Chr(13) + Chr(10) +
                'Vias: ' + IntToStr(ViaCount) + Chr(13) + Chr(10) +
                'Tracks: ' + IntToStr(TrackCount) + Chr(13) + Chr(10) +
                'Arcs: ' + IntToStr(ArcCount));
End;

{..............................................................................}
Procedure RunExport;
Begin
    ExportFootprintData;
End;
{..............................................................................}
