"""
Altium DelphiScript (.pas) footprint generator.

This module generates DelphiScript files that can be run inside Altium Designer
to programmatically create PCB footprints. This approach uses Altium's official
PCB API (IPCB_Pad, PCBServer, etc.) and is guaranteed to produce valid footprints.

Usage:
    1. Generate a .pas script from a Footprint model
    2. In Altium Designer, open a new/existing PcbLib file
    3. Run the script via DXP -> Run Script
    4. The footprint is created in the current library

Reference:
    - https://github.com/Altium-Designer-addons/scripting-reference
    - IPCB_Pad interface documentation
    - PCBServer.PCBObjectFactory for object creation

Coordinate System:
    - Altium uses internal units (1/10000 mil)
    - MilsToCoord() converts mils to internal units
    - MMsToCoord() converts mm to internal units
"""

from io import StringIO
from typing import TextIO

from models import (
    Footprint,
    Pad,
    PadType,
    PadShape,
    DrillType,
    Via,
    Outline,
)


# =============================================================================
# Constants - Altium DelphiScript enum values
# =============================================================================

# Pad shape constants
# Note: eRoundRectShape causes issues in AD26, using eRectangular as fallback
SHAPE_MAP = {
    PadShape.ROUND: "eRounded",
    PadShape.RECTANGULAR: "eRectangular",
    PadShape.ROUNDED_RECTANGLE: "eRectangular",  # MVP: Manual corner radius adjustment needed
    PadShape.OVAL: "eRounded",  # Oval uses eRounded with different X/Y sizes
}

# Hole type constants
HOLE_TYPE_MAP = {
    DrillType.ROUND: "eRoundHole",
    DrillType.SLOT: "eSlotHole",
}

# Layer constants
LAYER_TOP = "eTopLayer"
LAYER_MULTI = "eMultiLayer"
LAYER_TOP_OVERLAY = "eTopOverlay"


class DelphiScriptGenerator:
    """
    Generator for Altium DelphiScript (.pas) footprint creation scripts.

    This generator creates a DelphiScript that uses Altium's PCB API to
    create footprints programmatically. The script can be run inside
    Altium Designer to create the footprint in the current PCB library.

    Attributes:
        footprint: The Footprint model to generate
    """

    def __init__(self, footprint: Footprint):
        """
        Initialize the generator with a footprint.

        Args:
            footprint: The Footprint model containing all pad/via/outline data
        """
        self.footprint = footprint

    def generate(self) -> str:
        """
        Generate the complete DelphiScript (.pas) content.

        Returns:
            String containing the full script ready to run in Altium.
        """
        output = StringIO()

        self._write_header(output)
        self._write_main_procedure(output)

        return output.getvalue()

    def write_to_file(self, filepath: str) -> None:
        """
        Generate and write the script to a .pas file.

        Args:
            filepath: Path to the output .pas file
        """
        content = self.generate()
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(content)

    # =========================================================================
    # Private Methods - Script Generation
    # =========================================================================

    def _write_header(self, output: TextIO) -> None:
        """Write script header with comments and uses clause."""
        output.write(f"{{ Altium DelphiScript - Create Footprint: {self.footprint.name} }}\n")
        output.write("{ Generated by FootprintAI }\n")
        output.write("{\n")
        output.write(f"  Footprint: {self.footprint.name}\n")
        if self.footprint.description:
            output.write(f"  Description: {self.footprint.description}\n")
        output.write(f"  Pads: {len(self.footprint.pads)}\n")
        output.write(f"  Vias: {len(self.footprint.vias)}\n")
        output.write("}\n\n")

    def _write_main_procedure(self, output: TextIO) -> None:
        """Write the main procedure that creates the footprint."""
        output.write(f"Procedure CreateFootprint_{self._safe_name(self.footprint.name)};\n")
        output.write("Var\n")
        output.write("    Board      : IPCB_Board;\n")
        output.write("    CurrentLib : IPCB_Library;\n")
        output.write("    NewComp    : IPCB_LibComponent;\n")
        output.write("    Pad        : IPCB_Pad;\n")
        output.write("    Via        : IPCB_Via;\n")
        output.write("    Track      : IPCB_Track;\n")
        output.write("    Arc        : IPCB_Arc;\n")
        output.write("Begin\n")
        output.write("    // Try to get current PCB Library directly\n")
        output.write("    CurrentLib := PCBServer.GetCurrentPCBLibrary;\n")
        output.write("\n")
        output.write("    // If that fails, try via the board interface\n")
        output.write("    If CurrentLib = Nil Then\n")
        output.write("    Begin\n")
        output.write("        Board := PCBServer.GetCurrentPCBBoard;\n")
        output.write("        If Board <> Nil Then\n")
        output.write("        Begin\n")
        output.write("            If Board.IsLibrary Then\n")
        output.write("                CurrentLib := PCBServer.GetCurrentPCBLibrary;\n")
        output.write("        End;\n")
        output.write("    End;\n")
        output.write("\n")
        output.write("    If CurrentLib = Nil Then\n")
        output.write("    Begin\n")
        output.write("        ShowMessage('Please open a PCB Library document first.' + #13#10 +\n")
        output.write("                    'Make sure the library tab is active/focused.');\n")
        output.write("        Exit;\n")
        output.write("    End;\n\n")

        output.write("    // Create a new footprint component\n")
        output.write("    NewComp := PCBServer.CreatePCBLibComp;\n")
        output.write("    If NewComp = Nil Then\n")
        output.write("    Begin\n")
        output.write("        ShowMessage('Failed to create component.');\n")
        output.write("        Exit;\n")
        output.write("    End;\n\n")

        output.write(f"    NewComp.Name := '{self.footprint.name}';\n")
        if self.footprint.description:
            output.write(f"    NewComp.Description := '{self.footprint.description}';\n")
        output.write("\n")

        output.write("    // Begin modification\n")
        output.write("    PCBServer.PreProcess;\n\n")

        # Create all pads
        for i, pad in enumerate(self.footprint.pads):
            self._write_pad_creation(output, pad, i)

        # Create all vias
        for i, via in enumerate(self.footprint.vias):
            self._write_via_creation(output, via, i)

        # Create outline tracks
        if self.footprint.outline:
            self._write_outline_creation(output, self.footprint.outline)

        # Create Pin 1 indicator
        if self.footprint.pads:
            self._write_pin1_indicator(output)

        output.write("    // End modification\n")
        output.write("    PCBServer.PostProcess;\n\n")

        output.write("    // Register the component in the library\n")
        output.write("    CurrentLib.RegisterComponent(NewComp);\n")
        output.write("    CurrentLib.CurrentComponent := NewComp;\n\n")

        output.write("    // Refresh the library view\n")
        output.write("    CurrentLib.Board.ViewManager_FullUpdate;\n")
        output.write("    CurrentLib.RefreshView;\n\n")

        output.write(f"    ShowMessage('Footprint {self.footprint.name} created successfully!');\n")
        output.write("End;\n\n")

        # Write the Run entry point
        output.write("{ Main entry point }\n")
        output.write("Procedure Run;\n")
        output.write("Begin\n")
        output.write(f"    CreateFootprint_{self._safe_name(self.footprint.name)};\n")
        output.write("End;\n")

    def _write_pad_creation(self, output: TextIO, pad: Pad, index: int) -> None:
        """
        Write code to create a single pad.

        Args:
            output: Output stream
            pad: Pad model to create
            index: Pad index for comments
        """
        output.write(f"    // --- Pad {index + 1}: {pad.designator} ---\n")
        output.write("    Pad := PCBServer.PCBObjectFactory(ePadObject, eNoDimension, eCreate_Default);\n")
        output.write("    If Pad <> Nil Then\n")
        output.write("    Begin\n")

        # Position (convert mm to internal units)
        output.write(f"        Pad.X := MMsToCoord({pad.x:.4f});\n")
        output.write(f"        Pad.Y := MMsToCoord({pad.y:.4f});\n")

        # Designator
        output.write(f"        Pad.Name := '{pad.designator}';\n")

        # Layer
        if pad.pad_type == PadType.SMD:
            output.write(f"        Pad.Layer := {LAYER_TOP};\n")
        else:
            output.write(f"        Pad.Layer := {LAYER_MULTI};\n")

        # Shape and size
        shape = SHAPE_MAP.get(pad.shape, "eRectangular")
        output.write("        Pad.Mode := ePadMode_Simple;\n")
        output.write(f"        Pad.TopShape := {shape};\n")
        output.write(f"        Pad.TopXSize := MMsToCoord({pad.width:.4f});\n")
        output.write(f"        Pad.TopYSize := MMsToCoord({pad.height:.4f});\n")

        # Rotation
        if pad.rotation != 0:
            output.write(f"        Pad.Rotation := {pad.rotation:.3f};\n")

        # Drill hole for through-hole pads
        if pad.pad_type == PadType.THROUGH_HOLE and pad.drill:
            output.write(f"        Pad.HoleSize := MMsToCoord({pad.drill.diameter:.4f});\n")

            if pad.drill.drill_type == DrillType.SLOT and pad.drill.slot_length:
                output.write("        Pad.HoleType := eSlotHole;\n")
                # For slots: HoleSize is the slot width
                output.write(f"        Pad.HoleSize := MMsToCoord({pad.drill.diameter:.4f});\n")
                # Set slot length via HoleWidth property (slot length = HoleWidth in Altium)
                output.write(f"        Pad.HoleWidth := MMsToCoord({pad.drill.slot_length:.4f});\n")
                output.write(f"        // Slot: {pad.drill.diameter}mm width x {pad.drill.slot_length}mm length\n")
            else:
                output.write("        Pad.HoleType := eRoundHole;\n")

        output.write("        NewComp.AddPCBObject(Pad);\n")
        output.write("    End;\n\n")

    def _write_via_creation(self, output: TextIO, via: Via, index: int) -> None:
        """
        Write code to create a single via.

        Args:
            output: Output stream
            via: Via model to create
            index: Via index for comments
        """
        output.write(f"    // --- Via {index + 1} ---\n")
        output.write("    Via := PCBServer.PCBObjectFactory(eViaObject, eNoDimension, eCreate_Default);\n")
        output.write("    If Via <> Nil Then\n")
        output.write("    Begin\n")
        output.write(f"        Via.X := MMsToCoord({via.x:.4f});\n")
        output.write(f"        Via.Y := MMsToCoord({via.y:.4f});\n")
        output.write(f"        Via.Size := MMsToCoord({via.diameter:.4f});\n")
        output.write(f"        Via.HoleSize := MMsToCoord({via.drill_diameter:.4f});\n")
        output.write("        Via.LowLayer := eTopLayer;\n")
        output.write("        Via.HighLayer := eBottomLayer;\n")
        output.write("        NewComp.AddPCBObject(Via);\n")
        output.write("    End;\n\n")

    def _write_outline_creation(self, output: TextIO, outline: Outline) -> None:
        """
        Write code to create silkscreen outline.

        Args:
            output: Output stream
            outline: Outline model
        """
        half_w = outline.width / 2
        half_h = outline.height / 2
        line_width = outline.line_width

        # Four corners
        corners = [
            (-half_w, -half_h),
            (half_w, -half_h),
            (half_w, half_h),
            (-half_w, half_h),
        ]

        output.write("    // --- Silkscreen Outline ---\n")

        for i in range(4):
            x1, y1 = corners[i]
            x2, y2 = corners[(i + 1) % 4]

            output.write("    Track := PCBServer.PCBObjectFactory(eTrackObject, eNoDimension, eCreate_Default);\n")
            output.write("    If Track <> Nil Then\n")
            output.write("    Begin\n")
            output.write(f"        Track.X1 := MMsToCoord({x1:.4f});\n")
            output.write(f"        Track.Y1 := MMsToCoord({y1:.4f});\n")
            output.write(f"        Track.X2 := MMsToCoord({x2:.4f});\n")
            output.write(f"        Track.Y2 := MMsToCoord({y2:.4f});\n")
            output.write(f"        Track.Width := MMsToCoord({line_width:.4f});\n")
            output.write(f"        Track.Layer := {LAYER_TOP_OVERLAY};\n")
            output.write("        NewComp.AddPCBObject(Track);\n")
            output.write("    End;\n\n")

    def _write_pin1_indicator(self, output: TextIO) -> None:
        """Write code to create Pin 1 indicator - small filled dot outside pad."""
        pin1 = self._find_pin1()
        if not pin1:
            return

        # Calculate position outside Pin 1 pad
        # Direction is away from origin (component center)
        dir_x = -1 if pin1.x < 0 else (1 if pin1.x > 0 else -1)
        dir_y = -1 if pin1.y < 0 else (1 if pin1.y > 0 else 1)

        # Offset from pad edge (half pad size + gap + dot radius)
        pad_half_w = pin1.width / 2 if pin1.width else 0.3
        pad_half_h = pin1.height / 2 if pin1.height else 0.3
        gap = 0.2  # Gap between pad and dot
        dot_radius = 0.15  # Small dot

        # Position outside the pad
        ind_x = pin1.x + dir_x * (pad_half_w + gap + dot_radius)
        ind_y = pin1.y + dir_y * (pad_half_h + gap + dot_radius)

        output.write("    // --- Pin 1 Indicator (filled dot) ---\n")
        output.write("    Arc := PCBServer.PCBObjectFactory(eArcObject, eNoDimension, eCreate_Default);\n")
        output.write("    If Arc <> Nil Then\n")
        output.write("    Begin\n")
        output.write(f"        Arc.XCenter := MMsToCoord({ind_x:.4f});\n")
        output.write(f"        Arc.YCenter := MMsToCoord({ind_y:.4f});\n")
        output.write(f"        Arc.Radius := MMsToCoord({dot_radius:.4f});\n")
        output.write("        Arc.StartAngle := 0;\n")
        output.write("        Arc.EndAngle := 360;\n")
        # Line width >= 2*radius creates a filled circle
        output.write(f"        Arc.LineWidth := MMsToCoord({dot_radius * 2:.4f});\n")
        output.write(f"        Arc.Layer := {LAYER_TOP_OVERLAY};\n")
        output.write("        NewComp.AddPCBObject(Arc);\n")
        output.write("    End;\n\n")

    def _find_pin1(self) -> Pad | None:
        """Find Pin 1 in the footprint."""
        for pad in self.footprint.pads:
            if pad.designator == "1":
                return pad
        return self.footprint.pads[0] if self.footprint.pads else None

    def _safe_name(self, name: str) -> str:
        """Convert name to valid Pascal identifier."""
        # Replace invalid characters with underscores
        safe = ""
        for c in name:
            if c.isalnum():
                safe += c
            else:
                safe += "_"
        # Ensure starts with letter
        if safe and safe[0].isdigit():
            safe = "FP_" + safe
        return safe or "Footprint"


# =============================================================================
# Convenience Functions
# =============================================================================


def generate_delphiscript(footprint: Footprint) -> str:
    """
    Generate Altium DelphiScript content from a footprint.

    Args:
        footprint: The Footprint model to convert

    Returns:
        String containing the .pas script content

    Example:
        footprint = Footprint(name="SO-8", pads=[...])
        script = generate_delphiscript(footprint)
    """
    generator = DelphiScriptGenerator(footprint)
    return generator.generate()


def write_delphiscript(footprint: Footprint, filepath: str) -> None:
    """
    Generate and write a DelphiScript file from a footprint.

    Args:
        footprint: The Footprint model to convert
        filepath: Path to write the output .pas file

    Example:
        footprint = Footprint(name="SO-8", pads=[...])
        write_delphiscript(footprint, "SO-8_Create.pas")
    """
    generator = DelphiScriptGenerator(footprint)
    generator.write_to_file(filepath)
